<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/blog/dist/styles.css">
    <title>Igor Roztropiński</title>
    <meta property="description" content="Personal site of Igor Roztropiński" />
    <meta name="author" content="Igor Roztropiński" />
</head>

<body class="bg-black text-white post flex flex-col items-center justify-center">
    <div class="p-4 max-w-[1000px]">
        <h1 class="text-4xl font-bold text-center">Reduce the search space</h1>
       
        <h2>Searching through space</h2>
<p>When we work with a set of persisted (somewhere)  data, we obviously want our queries to be fast. 
Whenever I think about optimizing certain data query, be it SQL (mostly) or NoSQL, I find it useful to think about those problems as a search space problems. What I mean is that, you query will be fast, if your search space is small.
Building on that, if you search space is huge (you work with $10^6$, $10^9$ and more number of rows for example), you need to find a way to make your search space small again. There are a couple ways of doing that, so let&#39;s explore them!</p>
<h2>Changing schema</h2>
<p>First, seach space also related to the <em>size</em> fo each row that we (any given database) needs to scan. So, let&#39;s say that we have the following schema of the SQL database: </p>
<pre><code>CREATE TABLE account (
    id UUID PRIMARY KEY,
    name TEXT NOT NULL,
    state TEXT NOT NULL
    description TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL
);
</code></pre>
<p><br>Now, let&#39;s say that for 99% of our queries, we only take id and a name, and additionally description is pretty long in practice (like 1000+ characters). Let&#39;s say, for the sake of example, that we often do query:</p>
<pre><code>SELECT id, name FROM account WHERE name = ?;
</code></pre>
<p>So, we care only about two fields, additionaly (for some arbtrary reason, I know!) we can&#39;t index name field. Let&#39;s assume that we use Postgres database. Now, we will need to do full table scan, to fulfill this query. When our table have 5 columns each row has ~ 5n size (approximating of course, size of columns can vary a lot). Having $10^9$ we will need to scan:</p>
<pre><code>10 000 000 000 * 5n = 5 000 000 000,
where n is the averaged size of our columns
</code></pre>
<p>Simply changing schema to something like:</p>
<pre><code>CREATE TABLE account (
    id UUID PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE account_details (
    id UUID PRIMARY KEY REFERENCES account(id),
    state TEXT NOT NULL
    description TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL
);
</code></pre>
<p>Now, because we are interested only in two columns for our most frequently used query (id, name), our search space is reduced to </p>
<pre><code>10 000 000 000 * 2n = 2 000 000 000,
where n is the averaged size of our columns
</code></pre>
<p>...which is a 40% of previous size, so our queries need to search through ~ 2.5 less space. </p>
<p>We will get to <strong>partitioning</strong> later, but you can also think about it as <strong>vertical partitioning</strong>, since we slice our table into two separate vertical slices really. Vertical, because all rows are in both tables, but we have split previous row into two, where 2 columns are in the first table and 3 are in the second one.</p>
<h1>Indexing</h1>
<p>Index is just a separate datastructure that:</p>
<ul>
<li>have a particular structure that help with searching
points to a table (collection/document in the case of NoSQL databases) and</li>
</ul>
<h1>Partioning</h1>
<h1>Sharding</h1>
<h1>Conclusion</h1>
        
        <div class="text-4xl font-bold">---</div>
    </div>
</body>

</html>